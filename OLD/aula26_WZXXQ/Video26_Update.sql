-- UPDATING DATA
----------------------------------------

USE CURSO_SQL2014_IMPL
GO

-- THE BASIC COMMAND TO CHANGE ROWS IN SQL SERVER IS THE UPDATE COMMAND
-- NO MATTER WHAT YOU USE IT, AN UPDATE IS ALL THAT SQL SERVER UNDERSTAND

-- BASIC SYNTAX:

-- UPDATE <table> SET <column_1> = <value_1>
--                   ,<column_2> = <value_2> ...
-- WHERE <condition>
    
-- YOU NEED TO VERIFY ALL THE CONSTRAINTS (PK, FK, NULL, ETC)
-- YOU CAN ALSO USE THE NULL AND DEFAULT KEYWORDS

-- EXAMPLES:

CREATE TABLE T_UPDATE
(
	COL1 INT NOT NULL PRIMARY KEY,
	COL2 VARCHAR(10)
)
GO

INSERT T_UPDATE VALUES(1,'A')
INSERT T_UPDATE VALUES(2,'B')
INSERT T_UPDATE VALUES(3,'C')
INSERT T_UPDATE VALUES(4,'D')
GO

SELECT * FROM T_UPDATE

UPDATE T_UPDATE SET COL2 = 'X'

SELECT * FROM T_UPDATE

UPDATE T_UPDATE SET COL2 = 'A'
WHERE COL1 = 1

SELECT * FROM T_UPDATE

UPDATE T_UPDATE SET COL1 = 99
WHERE COL1 = 1

-- TIP: ALWAYS ALWAYS USE THE WHERE CLAUSE TO AVOID CHANGE THE 
-- ROWS YOU DON'T WANT TO CHANGE (VERY COMMON MISTAKE)

-- AN UPDATE CAN BE JUST AN UPDATE OR AN INTERNAL DELETE AND INSERT
-- MOST OF THE TIME YOU DON'T NEED TO WORRY ABOUT THAT

-- UPDATES OCCUPY TRANSACTION LOG SPACE, SO BE VERY CAREFULL
-- AVOID AT ALL COSTS LONG UPDATES, I.E. UPDATES THAT CHANGE A LOT OF ROWS AT ONCE
-- USE THE WHERE CLAUSE TO FILTER THE DATA

-- BAD SCENARIO: AN UPDATE THAT CHANGE A LOT OF ROWS AT ONCE
-- IT MAY BLOCK THE SERVER BECAUSE OF A TRANSACTIONS. KILL THE SESSION
-- OR EVEN STOP THE SERVER WONT HELP.

-- YOU CAN USE JOINS IN A UPDATE. THIS ALLOW YOU TO CHECK 
-- THE DATA BEFORE CHANGE IT. YOU MAY USES ALIASES FOR TABLES

-- ONLY THE ROWS OF ONE TABLE WILL BE CHANGED

-- IT MAY BE SIMPLER TO USE THE IN() OPERADOR

-- EXAMPLE: CHANGE THE PRICE OF THE PRODUCTS THAT WERE SOLD

SELECT *
FROM PRODUTOS
WHERE IDPRODUTO IN (SELECT IDPRODUTO FROM ITENS_PEDIDO)

SELECT DISTINCT A.IdProduto
FROM PRODUTOS A INNER JOIN ITENS_PEDIDO B
ON A.IdProduto = B.IdProduto

UPDATE PRODUTOS
SET PrcProducto = PrcProducto + 1
WHERE IDPRODUTO IN ( SELECT IDPRODUTO FROM ITENS_PEDIDO ) 

UPDATE PRODUTOS
SET PrcProducto = PrcProducto - 1
FROM PRODUTOS P INNER JOIN ITENS_PEDIDO I
ON P.IDPRODUTO = I.IdProduto

-- THE FOREIGN KEY CONSTRAINT MAY RECEIVE THE CASCADE CLAUSE
-- TO AUTOMATICALLY UPDATE ROWS. YOU CHANGE THE PARENT AND IT CHANGE THE CHILDREN
-- IT IS CALLED CASCADING REFERENTIAL INTEGRITY CONSTRAINT
-- EXAMPLE:


-- CREATES THE PARENT TABLE 

CREATE TABLE PARENT
(
  PARENT_ID  SMALLINT         NOT NULL PRIMARY KEY,
  PARENT_NAME CHAR(10)        NOT NULL,
  BIRTH_DATE  SMALLDATETIME   NOT NULL
)

-- CREATES THE CHILD TABLE

CREATE TABLE CHILD
( 
  CHILD_ID   SMALLINT        NOT NULL PRIMARY KEY,
  PARENT_ID  SMALLINT        NOT NULL ,
  CHILD_NAME CHAR(10)        NOT NULL,
  BIRTH_DATE SMALLDATETIME   NOT NULL,
  CHILD_SEX  CHAR(01)        NOT NULL
)

-- NOW CREATES THE FOREIGN KEY WITH THE CASCADE OPTION 

ALTER TABLE CHILD
ADD CONSTRAINT FK_CHILD FOREIGN KEY (PARENT_ID) REFERENCES PARENT(PARENT_ID)
    ON UPDATE CASCADE


-- INSERT SOME PARENT DATA
INSERT PARENT VALUES(1,'JOAO','01/05/65')
INSERT PARENT VALUES(2,'JOSE','01/05/65')
INSERT PARENT VALUES(3,'JOAQUIM','01/05/65')
INSERT PARENT VALUES(4,'JAIRO','01/05/65')

SELECT * FROM PARENT

/* ********************** */

-- INSERT SOME CHILD DATA
INSERT CHILD VALUES (1,1,'ROSA','01/25/85','F')
INSERT CHILD VALUES (2,1,'RAQUEL','02/25/85','F')
INSERT CHILD VALUES (3,1,'RICARDO','03/25/85','M')

INSERT CHILD VALUES (4,2,'MARCOS','01/25/85','M')
INSERT CHILD VALUES (5,2,'MARIA','01/25/85','F')

-- CHECK THE DATA
SELECT * FROM PARENT
SELECT * FROM CHILD

-- THE PARENT JOSE AND ITS CHILDREN
SELECT PARENT.PARENT_ID,
	   PARENT.PARENT_NAME,
       CHILD.CHILD_ID,
       CHILD.CHILD_NAME
FROM PARENT INNER JOIN CHILD
ON PARENT.PARENT_ID = CHILD.PARENT_ID
WHERE PARENT.PARENT_ID = 1

-- CHANGING THE PARENT_ID 1 TO 9
-- AND CASCADING THE CHANGES TO THE CRILDREN

UPDATE PARENT
SET PARENT_ID = 9
WHERE PARENT_ID = 1

SELECT * FROM PARENT
SELECT * FROM CHILD

SELECT PARENT.PARENT_ID,
	   PARENT.PARENT_NAME,
       CHILD.CHILD_ID,
       CHILD.CHILD_NAME
FROM PARENT INNER JOIN CHILD
ON PARENT.PARENT_ID = CHILD.PARENT_ID


